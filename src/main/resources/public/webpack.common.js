const path = require("path");
const CircularDependencyPlugin = require("circular-dependency-plugin");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const ESLintPlugin = require("eslint-webpack-plugin");
const prod = process.argv.indexOf("-p") !== -1;
const env = prod ? "prod" : "dev";

console.log("TARGET ENV: " + env);

module.exports = {
    entry: {
        main: "./ts/index.tsx"
    },

    // this puts our bundle.js file into current folder "public"
    output: {
        path: path.resolve(__dirname, "dist"),
        filename: "[name].[contenthash].js",
        clean: true
    },

    resolve: {
        extensions: [".tsx", ".ts", ".js", ".json", ".scss"]
    },

    module: {
        rules: [
            {
                test: /\.tsx?$/,
                use: [{
                    loader: "ts-loader",
                    options: {
                        configFile: "tsconfig." + env + ".json"
                    }
                }],
                exclude: /node_modules/
            },

            // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.
            // #sourceMap
            // {
            //     test: /\.js$/,
            //     enforce: "pre",
            //     use: [{
            //         loader: "source-map-loader"
            //     }]
            // },

            {
                // handles both scss or css files.
                test: /\.(sc|c)ss$/i,
                use: [{
                    loader: "style-loader"
                }, {
                    loader: "css-loader"
                }, {
                    loader: "sass-loader"
                }]
            },
            {
                test: /\.htm$/,
                use: [{
                    loader: "html-loader"
                }]
            },

            // Webpack 5 way of doing what used to be 'file-loader'
            {
                test: /\.(jpg)$/,
                type: "asset/resource"
            }
        ]
    },

    plugins: [
        new HtmlWebpackPlugin({
            filename: "../../templates/index.html",
            template: "indexTemplate.html",
            publicPath: "/dist",

            scriptLoading: "module",
            inject: "body"
        }),

        new HtmlWebpackPlugin({
            filename: "../../templates/error.html",
            template: "errorTemplate.html",
            publicPath: "/dist"
            // scriptLoading: "blocking",
            // inject: "head"
        }),

        new HtmlWebpackPlugin({
            filename: "../../templates/demo/tsx-test.html",
            template: "tsx-testTemplate.html",

            // we don't want any path prefix on our bundle file so this is empty.
            publicPath: "/dist"
            // scriptLoading: "blocking",
            // inject: "head"
        }),

        new ESLintPlugin({
            extensions: [".txs", ".ts", ".js"],
            exclude: "node_modules"
        }),

        new CircularDependencyPlugin({
            // `onDetected` is called for each module that is cyclical
            onDetected({ module: webpackModuleRecord, paths, compilation }) {
                // `paths` will be an Array of the relative module paths that make up the cycle
                // `module` will be the module record generated by webpack that caused the cycle
                var fullPath = paths.join(" -> ");
                if (fullPath.indexOf("node_modules") === -1) {
                    compilation.errors.push(new Error("CIRC. REF: " + fullPath));
                }
            }
        })
    ]
};
