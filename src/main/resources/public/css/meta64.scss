
@import "variables.scss";

$rootNodeBorder: true;
$highlightActiveMenuItems: false;

$border-radius: .3rem;
$borderRadiusLarge: 1em;
$borderRadiusMedium: .6em;

$input-bg: $gray-700;
$input-color: white;
$input-color-placeholder: #999;

$scrollTrack: $gray-900;
$scrollThumb: $gray-700;

//rgb(21,32,43); twitter background
$body-bg: darken(rgb(32, 34, 36), 7%);
$body-color: white;

$disabled-body-color: gray; //darken($body-color, 90%);

// This gives us awesome large checkboxes and radio buttons!!
$custom-control-indicator-size: 1.75rem;

@import "../node_modules/bootstrap/scss/bootstrap";

@import "bootswatch.scss";

$fontFamily: 'QuantaCustomFont','Roboto','Verdana','Helvetica','Arial','sans-serif';

//This does work (border around focused edit fields) but I don't need it.
// .form-control:focus {
//     border-color: green;
//     box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(255, 0, 0, 0.6);
// }

$menuItemHoverBackgroundColor: $primary;
$nodeBorderBottomColor: $gray-700;

$createdByMeBackgroundColor: green;
$createdByMeTextColor: white;

$createdByAnotherBackgroundColor: $gray-700;
$createdByAnotherTextColor: white;

$listBackgroundColor: lightGray;

$smallGap: 12px;
$bigGap: 24px;
$tinyGap: 8px;
$microGap: 4px;

$lightenRowFactor: 5;

/* warning: this 9px should match the 9px highlight border in Comp.ts */
$fatBorderSize: 9px;
$mediumBorderSize: 6px;
$smallBorderSize: 3px;

// @keyframes animatedBackground {
// 	from { 
//         background-size: 100% 100%; 
//     }

// 	to { 
//         background-size: 400% 400%; 
//     }
// }

// we tack this onto bootstrap btn-group, becasue without it, buttons stretch wider than normal when 
// wrapped to a new line (position) that where the row isn't full and has space to stretch. 
.btnGroup {
    display: inline;
}

.myjumbotron {
    background-size: 100% auto;
    background-image: url(/images/PIA09561_large.jpg);

    //This 100 and auto makes the image fill horizontally but not alter it's aspect ratio

    //background-size:100% 100%;
    height: 100vh;
    max-width: 100% !important;
    min-height: 100vh !important;
}

// .warpdrive {
//     animation: animatedBackground 2s ease-in;
// }

.mediaStreamInputOption {
    width: 30rem;
}

.myFooterText {
    font-size: 80%;
}

.mainLogoImg {
    /* this margin and display is for making the logo horizontally centered */
    margin: auto;    
    display: block;
}

.transparentBg {
    background-color: rgba(0, 0, 0, .7);
    //opacity: 0.7;
    border: 2px solid cadetblue;
    border-radius: $borderRadiusLarge;
}

.infoBlock {
    margin-bottom: 2em;
    //padding-right: 2em;
}

.welcome-container-with-navbar {
    margin-top: 4em;
}

.welcome-container-no-navbar {
    margin-top: 20px;
}

.navbar {
    margin-bottom: 0px;
}

.navbar-font {
    font-size: 1.4rem;
    font-weight: 400;
}

.navItem {
    margin-top: 8px;
}

.smallLogoButton {
    border: 1px solid gray;
    cursor: pointer;
}

.app-body {
    font-family: $fontFamily !important;
    padding-bottom: 1rem;
}

.welcome-body {
    font-family: $fontFamily !important;
    font-size: 1.4rem;
    font-weight: 300;
    line-height: 1.5;

    /* This top-padding is how the bootstrap example keept the main content from being covered by the navbar, but one of their primary examples
    was using 3.5rem instead. Not sure which is better. */
    padding-top: 4rem;

    padding-bottom: 1rem;
}

// todo-0: we never have navbar so these 'no-navbar' vars can be renamed.
.welcome-body-no-navbar {
    font-family: $fontFamily !important;
    font-size: 1.4rem;
    font-weight: 300;
    line-height: 1.5;

    padding-bottom: 1rem;
}

.highlightBorder {
    border: 1px solid green;
}

.binary-link {
    margin-left: $smallGap;
    margin-bottom: $smallGap;
    font-weight: bold; 
}

.normalText {
    font-weight: normal;
}

.avatarImage {
    max-width: 48px;
    max-height: 80px;
    cursor: pointer;
    margin-bottom: $tinyGap;
    // margin-left: $smallGap; //NO. When metadata is off this will be wrong, so add this margin to the metadata container itself.
}

.profileImage {
    border-radius: $borderRadiusLarge;
    width: 300px;
    cursor: pointer;
    padding: 8px;
    border: 6px dotted $nodeBorderBottomColor;
}

.readOnlyProfileImage {
    border-radius: $borderRadiusLarge;
    width: 300px;
    cursor: pointer;
    padding: 8px;
    border: 1px solid $nodeBorderBottomColor;
}

.friendImage {
    width: 200px;
    cursor: pointer;
    border: 2px solid $nodeBorderBottomColor;
    margin: 10px;
}

.userBio {
    margin: 10px;
}

.profileImageHolder {
    border-radius: $borderRadiusLarge;
    width: 300px;
    height: 300px;
    cursor: pointer;
    padding: 8px;
    border: 6px dotted $nodeBorderBottomColor;
}

.main-navbar {
    margin: 0px;
    padding: 0px;
}

.floatingControlBar {
    position: fixed;
    top: 0;
    right: 0;
    margin: 10px;
}

.floatingControlBarItem {
    display: block;
    width: 100%;
}

/* This is how the search terms get highlighted by wrapping them like this in 
the markdown **_term_** */
strong em { 
    font-style: normal; 
    font-weight: bold; 
    background-color: green;
} 

.width-7rem {
    width: 7rem;
}

.textfield-label {
    margin-bottom: 0px;
}

.checkboxLabel {
    margin-right: 16px;
    margin-bottom: $smallGap;
}

.radioLabel {
    margin-right: 16px;
    margin-bottom: $smallGap;
}

.radioButtonsBar {
    line-height: 2.5rem;
}

.checkboxContainerHeight {
    line-height: 2.5rem;
}

.inline-checkbox {
    display: inline-block;
    cursor: pointer;
}

.inline-radio {
    display: inline-block;
    cursor: pointer;
}

.form-group-border {
    border: 1px solid $gray-600;
    border-radius: .6em;
}

.edit-props-table {
    margin-top: 5px;
    margin-bottom: 5px;
    padding: $smallGap;
}

.fixedFont {
    font-family: 'Courier New', Courier, monospace;
}

.file-link {
    margin-top: $smallGap;
    margin-left: $smallGap;
    font-family: 'Courier New', Courier, monospace;
    font-weight: bold;
}

.folder-link {
    margin-top: $smallGap;
    margin-left: $smallGap;
    font-family: 'Courier New', Courier, monospace;
    font-weight: bold;
}

.dlgContainer {
    display: none;
}

.overlay {
    z-index: 2147483647;
    background-color: rgba(1, 1, 1, 0.1);
    bottom: 0;
    left: 0;
    position: fixed;
    right: 0;
    top: 0;
    cursor: progress;
    display: none;
}

.app-modal-title {
    margin-bottom: $smallGap;
    font-size: 150%;
}

.app-modal-title-close-icon {
    cursor: pointer;
    font-size: 125%;

    //this icon vertical centering doesn't work, but it's acceptable looking.
    vertical-align: middle;
}
 
.app-modal {
    //display: none;
    position: fixed;
    z-index: 16000000;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.6);
}

/* Modal Content/ Dialog Box. This is the outter frame of the dialog itself */

.app-modal-content {
    background-color: $modal-content-bg;
    border: 2px solid $modal-content-border-color;
    margin: $smallGap auto;
    padding: $smallGap;
    width: 75%;
    border-radius: .7em;
    max-width: 800px;
}

.app-modal-content-narrow-width {
    @extend .app-modal-content;
    max-width: 500px;
}

.app-modal-content-medium-width {
    @extend .app-modal-content;
    max-width: 650px;
}

.app-modal-content-fullscreen {
    background-color: $modal-content-bg;
    padding: $smallGap;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    overflow: auto;
}

//We hav this 80% width version so that the main menu can use it because to close that without selecting an option
//the user needs space to click in outside the menu which closes the menu.
//todo-0: note this now ONLY applies to main menu itself, so update variable names and designs accordingly.
.app-modal-content-almost-fullscreen {
    border: 2px solid $modal-content-border-color;
    background-color: $modal-content-bg;
    padding: $smallGap;
    width: 18em;
    max-width: 18em;
    height: 100%;
}

/* Modal Content/ Dialog Box */

.app-modal-menu {
    border: 2px solid $modal-content-border-color;
    left: 0;
    top: 0;
    padding: 0px;
    width: 20%;
    margin-top: 60px;
    margin-left: $smallGap;
    margin-right: $smallGap;
    margin-bottom: $smallGap;
    max-width: 400px;
    min-width: 350px;
    background-color: $modal-content-bg;
}

.leftNavPanel {
    overflow-y: auto;
    
    max-height: 100%;
    height: 100%;
    
    padding: 10px;
}

@import 'scrollbar.scss';

.tab-buttons-container {
    // margin-top: 8px;
    margin-bottom: 8px;
}

.rightNavPanel {
    padding: 15px; 
}

.my-tab-pane {
    width: 100%;
}

.tab-content {
    margin-left: 0px;
    margin-right: 0px;
}

.ipfs-text {
    margin: $smallGap;
    padding: 5px;
}

@import 'nav.scss';

@import 'menu.scss';

.small-margin-right {
    margin-right: 8px;
}

//The width/height looks awesome, but FireFox is jank so for now we will just use the smaller native controls.
input[type="checkbox"] {
    // height: 25px;
    // width: 25px;
    margin-right: 8px;
    margin-top: 16px;
    margin-bottom: 16px;
    margin-left: 8px
}

//The width/height looks awesome, but FireFox is jank so for now we will just use the smaller native controls.
input[type="radio"] {
    // height: 25px;
    // width: 25px;
    margin-right: 8px;
    margin-top: 16px;
    margin-bottom: 16px;
    margin-left: 8px
}

.myRadioButton {
    margin-right: 2em;
}

.edit-prop-checkbox-col {
    width: 50px;
    display: table-cell;
    margin-left: 16px;
}

.edit-prop-textfield-col {
    display: table-cell;
}

.row-toolbar {
    margin-left: 16px;
}

/* I experimented with limiting height of rows and allowing individual scrolling on nodes but
   i think usability and asthetics make this slightly awkward. You can simply uncomment these styles
   and look, any time, to remember what that looks like. The style is in place in the code
   */

.tallTextContent {
    max-height: 650px;
}   

.centeredTitle {
    width: 500px;
    /* This margin trick causes horizontal centering */
    margin: 0 auto;
}

.list-group-menu-item {
    background-color: transparent;
    padding: 10px;
}

.list-group-transparent {
    background-color: transparent;
    padding: 10px; 
}

.audioDownloadLink {
    margin-left: $smallGap;
}

.videoDownloadLink {
    margin-left: $smallGap;
}

.marginLeft {
    margin-left: $smallGap;
}

.marginRight {
    margin-right: $smallGap;
}

.microMarginTop {
    margin-top: $microGap;
}

.marginTop {
    margin-top: $smallGap;
}

.bigMarginRight {
    margin-right: $bigGap; 
}

.bigMarginBottom {
    margin-bottom: $bigGap; 
}

.anchorBigMarginBottom {
    display: inline-block;
    margin-bottom: $bigGap; 
}

.microMarginTop {
    margin-top: $microGap;
}

.marginBottom {
    margin-bottom: $smallGap;
}

.marginAll {
    margin: $smallGap;
}

@import 'list.scss';

.small-padding {
    margin-top: 7px;
    padding: 4px;
}

.horizontalLayout {
    //margin-top: 5px;
    //margin-left: 5px;
}

@import 'button.scss';

.basicButton {
    //margin-right: 7px;
}

.pre-textarea, .pre-textfield {
     //WARNING: Setting a font family here (other than inherit) causes noticeable flicker whenever react re-renders (during focus and blur eventing), 
     //but the solution appeared to be to set the font on the PARENT div of an input control (to monospace), and then use 'inherit' here as the actual font-family.
    font-family: inherit; //monospace;
}

.my-ace-editor {
    border: 1px solid $gray-500;
}

.textfield {
    margin-bottom: $smallGap;
}

/* We use a tiny gap for password text fields so that the 'Show Password" button can be very close below */
.passwordTextField {
    margin-bottom: $tinyGap;
}

.rowIcon {
    margin-left: 10px;
    margin-right: 6px;
    vertical-align: middle;
    cursor: pointer;
}

.passwordEyeIcon {
    cursor: pointer;
    margin-left: 10px;
}

.bash-script {
    margin-left: 1em;
    margin-top: 1em;
}

.markdown-content {
    padding-top: .5em;
    padding-left: 1em;
    padding-bottom: .5em;
}

// These borders make the hash-created titles (like '### Title') look really attractive, but it looks ugly 
// when there's a single line title in the root node which itself has a border (and must for clarity as the root node)
// so for now let's not do these unless/until we find a better way to indicate to user clearly that the root node
// is a very special one relative to the page.
//
// .markdown-content h1 {
//     border-bottom: 4px solid $gray-700;
// }

// .markdown-content h2 {
//     border-bottom: 3px solid $gray-700;
// }

// .markdown-content h3 {
//     border-bottom: 2px solid $gray-700;
// }

// .markdown-content h4 {
//     border-bottom: 1px solid $gray-700;
// }

// .markdown-content h5 {
//     // border-bottom: 1px solid $gray-700;
// }

// .markdown-content h6 {
//     // border-bottom: 1px solid $gray-700;
// }

// without this any multi-paragraph text that our markdown renders always has too much spacing at the bottom. We already specify the
// amount of spacing we want in the markdown-content style itself so we stop this from messing that up with this 'last-child' style
.markdown-content p:last-child {
    margin-bottom: 0px;
}

.markdown-content kbd,
.markdown-content pre,
.markdown-content samp {
    /*
    background-color: black;
    color: green;
    font-weight: bold;
    
    display: block;
    font-family: monospace;
    white-space: pre;
    */
    //font-size: 10%;
    /* overflow: auto; 
    max-height: 15em;
    border: 1px dotted gray;
    */
    
    width: 100%; 
    border: 1px dotted green;
}

.attached-img-in-row {
    cursor: pointer;
    margin-left: $smallGap;
    margin-bottom: $smallGap;
    border-radius: .6em;
    border: 1px solid $gray-700
}

.attached-img-in-editor {
    cursor: pointer;
    border-radius: .6em;
    border: 1px solid $gray-700
}

.meta64-input {
    max-width: 50%;
}

@import 'dropzone.scss';

.systemFileRow {
    margin-botom: 16px;
}

.systemFileActionLink {
    cursor: pointer;
    margin-right: 16px;
    border-bottom: 1px dotted gray;
}

.systemFile {
    font-family: Courier New, Courier, Roboto, Tahoma, Verdana, Arial;
    cursor: pointer;
    /* background: lightGray; */
    padding-bottom: 5px;
}

.ace-edit-panel {
    margin-top: $smallGap;
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 200px;
}

.vert-space {
    display: block;
    height: 0.5em;
}

.mainTabPanel {
    //border: 1px solid black;
    //background-color: $mainContentBackground;
    //setting a max-width here ruins the centering horizontally on the page, my goal was
    //to narrow the main tab content in center of page
    //WARNING: I think the bootstrap 'main' entity is what is setting the width here and it didn't work to chagne it here.
    // max-width: 750px;
    
    //I'd prefer to have NO margin, but the top margin is getting forced so I'll add a bottom margin for consistency for now
    margin-bottom: $smallGap;
    //margin-top: 0px;
    width: 100%;
}

.searchResultsPanel {
    // padding: $smallGap;
    // margin: $smallGap;
}

.timelinePanel {
    // padding: $smallGap;
    // margin: $smallGap;
}

.mainNodeContentStyle {
    outline: none;

    @if $rootNodeBorder {
        border: $mediumBorderSize solid $nodeBorderBottomColor; 
        border-radius: $borderRadiusLarge; 
    } 
    @else {
        border-left: $fatBorderSize solid $nodeBorderBottomColor; 
    }
    
    padding-right: 8px;
    padding-top: 8px;
}

.vertical-layout-row {
    margin-bottom: $smallGap;
}

.validationError {
    color: #E74C3C;
    margin-bottom: 0px;
}

.validationErrorBorder {
    border: 2px solid #E74C3C;
}

.txtFieldLabel {
    margin-bottom: .25rem;
}

.dialog-header {
    font-weight: bold;
    font-size: large;
    margin-top: $smallGap;
    margin-bottom: $smallGap;
}

.created-by-me {
    background: $createdByMeBackgroundColor;
    color: $createdByMeTextColor;
    padding: 4px;
    margin-right: 10px;
    margin-left: 10px;
}

.created-by-other {
    background: $createdByAnotherBackgroundColor;
    color: $createdByAnotherTextColor;
    padding: 4px;
    margin-right: 10px;
    margin-left: 10px;
}

.header-text {
    font-size: small;
    margin-left: 8px;
    margin-bottom: 8px;
    //padding-top: $microGap;
    cursor: pointer;
}

/* This positioning puts the plus buttion right outside the row to the right between rows
   so it's intuitive where the insert goes */
.plusButtonFloatRight {
    position: absolute;
    top: -1.1rem;
    right: -3.2rem;
}

@keyframes fadeToHidden {
    from {opacity: 1;}
    to {opacity: 0;}
}

.compHidden {
    //visibility: hidden;

    // animating the hiding part doesn't work well, because the effect gets interrupted by other parts of 
    // our animation flow, so we have to set to hidden instantly without animation.
    // animation-name: fadeToHidden;
    // animation-duration: 1s;

    opacity: 0;
}

/* Note: visibility is not allowed to be animated. This is a rule of CSS engines, not our own limitation. Also we don't set the 
'from' value becasue if it's already visibible 'opacity=1' we don't want to cause a screen flicker by setting invisible first for no reason.
*/
@keyframes fadeToVisible {
    // from {opacity: 0;}
    to {opacity: 1;}
}

.compVisible {
    // visibility: visible;
    animation-name: fadeToVisible;
    animation-duration: 1s;
}

.row-footer {
    font-size: small;
    margin-left: 16px;
    cursor: pointer;
}

.nodeName {
    padding: 4px;
    margin-right: 10px;
}

.content-narrow {
    max-width: 650px;
}

.content-medium {
    max-width: 800px;
}

.content-wide {
    max-width: 950px;
}

.mousePointer {
    cursor: pointer;
}

.tags-content {
    margin-left: 1em;
    /* we limit page width of text content, because text that goes to wide
		becomes difficult to read.
	*/
    border: 1px dotted lightGray;
    max-width: 800px;
    background: #f9e79f;
}

.property-table {
    margin-left: 1em;
}

.prop-table-row {
    width: 100%;
}

.prop-table-name-col {
    width: 25%;
}

.prop-table-val-col {
    width: 70%;
}

.prop-table {
    width: 100%;
}

.node-table-row {
    position: relative;
    padding-right: 1em;
    outline: none;
    padding-top: 8px;
    padding-bottom: 8px;
}

.editing-border {
    // border-bottom: 3px dotted $nodeBorderBottomColor;
    border-bottom: 1px dotted lightslategray;
}

.non-editing-border {
    border-bottom: 1px dotted lightslategray;
}

.editing-border {
    // border-bottom: 3px dotted $nodeBorderBottomColor;
    border-bottom: 1px dotted lightslategray;
}

/*
With "Display: table", the only way to get the internal 'node-grid-item' cell content to render with the SAME
height as the actual cell (i.e. fill up the entire cell) is to use "height: 100%" on the table, and the table-row, 
and the table-cell (all three)

update: oops, that 100% is causing vertical scrollbar to ALWAYS show up because something's off by a few pixels, so
i'm backing out for now
*/
.node-grid-table {
    display: table;
    width: 100%;
    table-layout: fixed;
    //margin-top: 10px;
    //height: 100%;

    // if you ever need rounded cells, these two are needed with that.
    // border-collapse: separate;
    // border-spacing: 10px;
}

.node-grid-item {
    padding-right: 1.5em;
    outline: none;
    height: 100%;
    width: 100%;
}

.node-grid-row {
    display: table-row;
}

.node-grid-cell {
    border: 1px dotted gray;
    overflow-x: auto;
    display: table-cell;
    //height: 100%;

    //not doing rounded cells because the selector (selected node) marker in them is asthetically ugly
    //border-radius: $borderRadiusMedium;
}

.node-table-row .top-right-image {
    position: absolute;
    top: 0;
    right: 0;
}

.active-row {
    border-left: $fatBorderSize solid $primary;
}

.active-row:hover {
    background-color: lighten($body-bg, $lightenRowFactor);
}

.inactive-row {
    border-left: $fatBorderSize solid transparent;
}

.inactive-feed-row {
    border-left: 2px solid $nodeBorderBottomColor;
    margin-left: 25px;
}

.inactive-feed-row-parent {
    border-bottom: 2px solid $nodeBorderBottomColor;
}

.inactive-row:hover {
    background-color: lighten($body-bg, $lightenRowFactor);
}

.active-row-main {
    @if $rootNodeBorder {
        border: $mediumBorderSize solid $primary;
    } 
    @else {
        border-left: $fatBorderSize solid $primary; 
    }
}

.active-row-main:hover {
    background-color: lighten($body-bg, $lightenRowFactor);
}

.inactive-row-main {
    @if $rootNodeBorder {
        border: $mediumBorderSize solid $nodeBorderBottomColor; 
    }
    @else {
        border-left: $fatBorderSize solid $nodeBorderBottomColor; 
    }
}

.inactive-row-main:hover {
    background-color: lighten($body-bg, $lightenRowFactor);
}

.main {
    background-color: #eee;
}

@import 'sidebar.scss';

.smallHeading {
    font-size: 1.3rem;
}

.form-control-dark {
    color: #fff;
    background-color: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.1);
}

.form-control-dark:focus {
    border-color: transparent;
    box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.25);
}

.border-top {
    border-top: 1px solid #e5e5e5;
}

.border-bottom {
    border-bottom: 1px solid #e5e5e5;
}

.rss-feed-listing {
    margin-top: $smallGap;
    margin-left: $smallGap;
    max-width: 800px;
}

.testHighlight {
    background-color: green;
}

@keyframes fadeInRowBkg {
    from {background-color: $nodeBorderBottomColor;}
    to {background-color: transparent;}
}
  
.fadeInRowBkgClz {
    animation-name: fadeInRowBkg;
    animation-duration: 2.5s;
}

.rowFooterIcon {
    margin-right: 12px;
    margin-bottom: 12px;  
    vertical-align: middle;
    cursor: pointer;
}

.userFeedItem {
    border-radius: $borderRadiusMedium;
    border: 4px solid $nodeBorderBottomColor;
    margin-bottom: 8px;
}

.userFeedParent {
    border: 2px solid $nodeBorderBottomColor;
}

.iconToggleOn {
    border: 2px solid white;
    padding: 5px;
}

.iconToggleOff {
    border: 2px solid transparent;
    padding: 5px;
}

.selectLabel {
    margin-bottom: 0px;
    margin-right: 6px;
}

.binaryEditorSection {
    margin-left: 2px;
    margin-right: 2px;
    padding: 10px;
    border-radius: .6em;
    border: 2px solid $gray-700
}

.editBinaryContainer {
    padding-left: 0px;
}

.heading5 {
    font-size: 1.2rem;
    font-weight: 500;
    line-height: 1.2;
}

.dialogContentArea {
    //border: 1px solid red;
    overflow: auto;
}

.priorityTag {
    border-radius: 1em;
    font-size: 1rem;
    font-weight: 500;
    line-height: 1;
    padding: 4px;
    margin-left: 5px;
}

.priorityTag1 {
    @extend .priorityTag;
    border: 5px solid red;
}

.priorityTag2 {
    @extend .priorityTag;
    border: 5px solid orange;
}

.priorityTag3 {
    @extend .priorityTag;
    border: 5px solid yellow;
}

.priorityTag4 {
    @extend .priorityTag;
    border: 5px solid green;
}

.priorityTag5 {
    @extend .priorityTag;
    border: 5px solid blueviolet;
}

.betweenRowsContainer {
    //border: 1px solid red;
    //width: 100%;
    //margin-top: 4px;
}

.quickEditTextArea {
    width: 100%;
    //background-color: transparent;
    //color: white;
}

.clickToEdit {
    width: 100%;
    height: 2rem;
    //a span inside a div won't utilize it's 100% width unless it has display block.
    display: block;
    cursor: pointer;
    border: 1px solid transparent;

    //Warning: Any gap here will create a bizarre resizing of the target area during a 'dragover' operation when dragging another node over it.
    //margin-top: $microGap;
}

.clickToEdit:hover {
    @extend .clickToEdit;
    border: 1px solid $nodeBorderBottomColor;
}

.quickEditSpan {
    width: 100%;
}

.quickEditFormArea {
    background-color: $modal-content-bg;
    //border: 2px solid $modal-content-border-color;
    //border-radius: $borderRadiusLarge;
    margin: $smallGap;
    //margin-top: $smallGap;
    //margin-bottom: $smallGap;
}

.inlineEditFormArea {
    background-color: $modal-content-bg;
    //border: 2px solid $modal-content-border-color;
    //border-radius: $borderRadiusLarge;
    //padding: $smallGap;
    margin-left: $smallGap;
}

.durationTypeInput {
    max-width: 8em;
}

@import 'breadcrumbs.scss';
@import 'media-queries.scss';
